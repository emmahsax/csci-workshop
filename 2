Adding next lessons
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch add_next_part_of_go_course
# Your branch is up to date with 'origin/add_next_part_of_go_course'.
#
# Changes to be committed:
#	new file:   master-go-programming/section_12/lesson_90-91/main.go
#	new file:   master-go-programming/section_12/lesson_92-95/main.go
#	new file:   master-go-programming/section_12/lesson_96-97/main.go
#	new file:   master-go-programming/section_12/lesson_98-100/main.go
#	new file:   master-go-programming/section_13/lesson_101/main.go
#	new file:   master-go-programming/section_14/lesson_102-106/main.go
#	new file:   master-go-programming/section_15/lesson_107/main.go
#	new file:   master-go-programming/section_16/lesson_108-109/main.go
#	new file:   master-go-programming/section_16/lesson_110-111/main.go
#	new file:   master-go-programming/section_16/lesson_112-113/main.go
#	new file:   master-go-programming/section_16/lesson_114-115/main.go
#	new file:   master-go-programming/section_16/lesson_116-117/main.go
#	new file:   master-go-programming/section_16/lesson_118-119/main.go
#	new file:   master-go-programming/section_16/test.md
#	new file:   master-go-programming/section_17/lesson_120/main.go
#	new file:   master-go-programming/section_17/new.txt
#	new file:   master-go-programming/section_17/test.md
#
# ------------------------ >8 ------------------------
# Do not modify or remove the line above.
# Everything below it will be ignored.
diff --git a/playing_with_go/master-go-programming/section_12/lesson_90-91/main.go b/playing_with_go/master-go-programming/section_12/lesson_90-91/main.go
new file mode 100644
index 0000000..b7c4591
--- /dev/null
+++ b/playing_with_go/master-go-programming/section_12/lesson_90-91/main.go
@@ -0,0 +1,62 @@
+/////////////////////////////////
+// String is Go
+// Go Playground: https://play.golang.org/p/-o07MQbIsDv
+/////////////////////////////////
+
+package main
+
+import (
+	"fmt"
+)
+
+func main() {
+
+	// Strings are defined between double quotes "..."
+	// Strings in Go are UTF-8 encoded by default
+	// A string is in fact a slice of bytes in Go
+
+	// declaring a string
+	s1 := "Hi there  Go!"
+
+	// printing a string
+	fmt.Printf("%s\n", s1) // => Hi there  Go!
+	fmt.Printf("%q\n", s1) // => "Hi there  Go!"
+
+	// using double-quotes inside double quotes
+	fmt.Println("He say: \"Hello!\"")
+
+	// double quotes inside backticks (backquote)
+	fmt.Println(`He say: "Hello!"`)
+
+	// a string literal inclosed in backticks is called a raw string and it is interpreted literally.
+	// backslashes or \n  have no special meaning
+	s2 := `Hi there Go!`
+	fmt.Println(s2)
+
+	// declaring a multiline string
+	fmt.Println("Price: 100 \nBrand: Nike")
+
+	//the same with:
+	fmt.Println(`
+Price: 100
+Brand: Nike`)
+
+	// using backslashes inside a string:
+	fmt.Println(`C:\Users\Andrei`)
+	fmt.Println("C:\\Users\\Andrei")
+
+	// concatenating strings (+)
+	// Go creates a new string because strings are immutable in Go (this is not efficient).
+	var s3 = "I love " + "Go " + "Programming"
+	fmt.Println(s3 + "!") // -> I love Go Programming!
+
+	// getting an element (byte) of a string:
+	fmt.Println("Element at index zero:", s3[0]) // => 73 (ascii code for I)
+	//  a string is in fact a slice of bytes in Go
+
+	// To get actual character instead of ascii code:
+	fmt.Println("Element at index zero:", string(s3[0]))
+
+	// strings are immutable and can't be changed
+	// s3[5] = 'x' // => error: Cannon assign to s3[5].
+}
diff --git a/playing_with_go/master-go-programming/section_12/lesson_92-95/main.go b/playing_with_go/master-go-programming/section_12/lesson_92-95/main.go
new file mode 100644
index 0000000..85f5d54
--- /dev/null
+++ b/playing_with_go/master-go-programming/section_12/lesson_92-95/main.go
@@ -0,0 +1,70 @@
+/////////////////////////////////
+// Strings, Runes, Bytes and Unicode Code Points
+// Go Playground: https://play.golang.org/p/pttCqLAAvKA
+/////////////////////////////////
+
+package main
+
+import (
+	"fmt"
+	"strings"
+	"unicode/utf8"
+)
+
+func main() {
+
+	// characters or rune literals are expressed in Go by enclosing them in single quotes
+	// declaring a variable of type rune (alias to int32)
+	var1 := 'a'
+	fmt.Printf("Type: %T, Value:%d \n", var1, var1) // => Type: int32, Value:97
+	// value is 97 (the code point for a)
+
+	// declaring a string value that contains non-ascii characters
+	str := "ţară" // ţară means country in Romanian
+	// 't', 'a' ,'r' and 'a' are runes and each rune occupies beetween 1 and 4 bytes.
+
+	fmt.Printf("String for reference: %s\n", str)
+
+	//The len() built-in function returns the no. of bytes not runes or chars.
+	fmt.Println("No. of bytes in string:", len(str)) // -> No. of bytes in string: 6 (4 runes in the string but the byte length is 6)
+
+	// returning the number of runes in the string (what we'd typically think of as string length)
+	m := utf8.RuneCountInString(str)
+	fmt.Println("No. of runes in string:", m) // => No. of runes in string: 4
+
+	// by using indexes we get the byte at that position, not rune.
+	fmt.Println("Byte (not rune) at position 1:", str[1]) // -> 163
+	r, _ := utf8.DecodeRuneInString(str[2:])
+	fmt.Printf("Rune at position 1: %c\n", r) // -> Rune at position 1: a (need to use index 2 because ţ takes up two bytes)
+
+	// decoding a string byte by byte (the bytes don't match up with the runes)
+	for i := 0; i < len(str); i++ {
+		fmt.Printf("%d -> %c, ", i, str[i]) // -> Å£arÄ
+	}
+
+	fmt.Println("\n" + strings.Repeat("#", 10))
+
+	// decoding a string rune by rune manually:
+	for i := 0; i < len(str); {
+		r, size := utf8.DecodeRuneInString(str[i:]) // it returns the rune in string in variable r
+		//and its size in bytes in variable size
+
+		// printing out each rune
+		fmt.Printf("%c", r) // -> ţară
+		i += size           // incrementing i by the size of the rune in bytes
+	}
+
+	fmt.Println("\n" + strings.Repeat("#", 10))
+
+	// decoding a string rune by rune automatically:
+	for i, r := range str { //the first value returned by range is the index of the byte in string where rune starts
+		fmt.Printf("%d -> %c, ", i, r) // => ţară
+	}
+
+	my_byte := byte('b')
+	my_rune := 'b'
+
+	fmt.Printf("\nByte: %c = %d\nRune: %c = %U\n", my_byte, my_byte, my_rune, my_rune)
+	// -> Byte: b = 98
+	//    Rune: b = U+0062
+}
diff --git a/playing_with_go/master-go-programming/section_12/lesson_96-97/main.go b/playing_with_go/master-go-programming/section_12/lesson_96-97/main.go
new file mode 100644
index 0000000..b4144ce
--- /dev/null
+++ b/playing_with_go/master-go-programming/section_12/lesson_96-97/main.go
@@ -0,0 +1,28 @@
+/////////////////////////////////
+// Slicing Strings
+// Go Playground: https://play.golang.org/p/8ZUrXBhcyAJ
+/////////////////////////////////
+
+package main
+
+import "fmt"
+
+func main() {
+
+	// Slicing a string is efficient because it reuses the same backing array
+	// Slicing returns bytes not runes
+
+	s1 := "abcdefghijkl"
+	fmt.Println(s1[2:5]) // -> cde (bytes from 2 (included) to 5 (excluded))
+
+	s2 := "中文维基是世界上"
+	fmt.Println(s2[0:2]) // -> � - the unicode representation of bytes from index 0 and 1.
+
+	// returning a slice of runes
+	// 1st step: converting string to rune slice
+	rs := []rune(s2)
+	fmt.Printf("%T\n", rs) // => []int32
+
+	// 2st step: slicing the rune slice
+	fmt.Println(string(rs[0:3])) // => 中文维
+}
diff --git a/playing_with_go/master-go-programming/section_12/lesson_98-100/main.go b/playing_with_go/master-go-programming/section_12/lesson_98-100/main.go
new file mode 100644
index 0000000..a715078
--- /dev/null
+++ b/playing_with_go/master-go-programming/section_12/lesson_98-100/main.go
@@ -0,0 +1,100 @@
+/////////////////////////////////
+// Strings Package
+// Go Playground: https://play.golang.org/p/uBy1U0Zve87
+/////////////////////////////////
+
+package main
+
+import (
+	"fmt"
+	"strings"
+)
+
+func main() {
+
+	// declaring a variable of type func to call the Println function easier.
+	p := fmt.Println
+
+	// it returns true whether a substr is within a string
+	result := strings.Contains("I love Go Programming!", "love")
+	p(result) // -> True
+
+	// it returns true whether any Unicode code points are within our string, and false otherwise.
+	result = strings.ContainsAny("success", "xy")
+	p(result) // => false
+
+	// it reports whether a rune is within a string.
+	result = strings.ContainsRune("golang", 'g')
+	p(result) // => true
+
+	// it returns the number of instances of a substring in a string
+	n := strings.Count("cheese", "e")
+	p(n) // => 3
+
+	// if the substr is an empty string Count() returns 1 + the number of runes in the string
+	n = strings.Count("five", "")
+	p(n) // => 5 (1 + 4 runes)
+
+	// ToUpper() and ToLower() return a new string with all the letters
+	// of the original string converted to uppercase or lowercase.
+	p(strings.ToLower("Go Python Java")) // -> go python java
+	p(strings.ToUpper("Go Python Java")) // -> GO PYTHON JAVA
+
+	// comparing strings (case matters)
+	p("go" == "go") // -> true
+	p("Go" == "go") // -> false
+
+	// comparing strings (case doesn't matter) -> it is not efficient
+	p(strings.ToLower("Go") == strings.ToLower("go")) // -> true
+
+	// EqualFold() compares strings (case doesn't matter) -> it's efficient
+	p(strings.EqualFold("Go", "gO")) // -> true
+
+	// it returns a new string consisting of n copies of the string that is passed as the first argument
+	myStr := strings.Repeat("ab", 10)
+	p(myStr) // => abababababababababab
+
+	// it returns a copy of a string by replacing a substring (old) by another substring (new)
+	myStr = strings.Replace("192.168.0.1", ".", ":", 2) // it replaces the first 2 occurrences
+	p(myStr)                                            // -> 192:168:0.1
+
+	// if the last argument is -1 it replaces all occurrences of old by new
+	myStr = strings.Replace("192.168.0.1", ".", ":", -1)
+	p(myStr) // -> 192:168:0:1
+
+	// ReplaceAll() returns a copy of the string s with all non-overlapping instances of old replaced by new.
+	myStr = strings.ReplaceAll("192.168.0.1", ".", ":")
+	p(myStr) // -> 192:168:0:1
+
+	// it slices a string into all substrings separated by separator and returns a slice of the substrings between those separators.
+	s := strings.Split("a,b,c", ",")
+	fmt.Printf("%T\n", s)                  // -> []string
+	fmt.Printf("strings.Split():%#v\n", s) // => strings.Split():[]string{"a", "b", "c"}
+
+	// If separator is empty Split function splits after each UTF-8 rune literal.
+	s = strings.Split("Go for Go!", "")
+	fmt.Printf("strings.Split():%#v\n", s) // -> []string{"G", "o", " ", "f", "o", "r", " ", "G", "o", "!"}
+
+	// Join() concatenates the elements of a slice of strings to create a single string.
+	// The separator string is placed between elements in the resulting string.
+	s = []string{"I", "learn", "Golang"}
+	j := strings.Join(s, "-")
+	fmt.Printf("%T\n", j) // -> string
+	p(j)                  // -> I-learn-Golang
+
+	// splitting a string by whitespaces and newlines.
+	myStr = "Orange Green \n Blue Yellow"
+	fields := strings.Fields(myStr) // it returns a slice of strings
+	fmt.Printf("%T\n", fields)      // -> []string
+	fmt.Printf("%#v\n", fields)     // -> []string{"Orange", "Green", "Blue", "Yellow"}
+
+	// TrimSpace() removes leading and trailing whitespaces and tabs.
+	newStr := "\t Goodbye Windows, Welcome Linux!\n "
+	fmt.Printf("%q\n", newStr)
+	s1 := strings.TrimSpace(newStr)
+	fmt.Printf("%q\n", s1) // "Goodbye Windows, Welcome Linux!"
+
+	// To remove other leading and trailing characters, use Trim()
+	s2 := strings.Trim("...Hello, Gophers!!!?", ".!?")
+	fmt.Printf("%q\n", s2) // "Hello, Gophers"
+}
diff --git a/playing_with_go/master-go-programming/section_13/lesson_101/main.go b/playing_with_go/master-go-programming/section_13/lesson_101/main.go
new file mode 100644
index 0000000..7aa0815
--- /dev/null
+++ b/playing_with_go/master-go-programming/section_13/lesson_101/main.go
@@ -0,0 +1,86 @@
+package main
+
+import (
+	"fmt"
+	"strings"
+	"unicode/utf8"
+)
+
+func main() {
+	// EXERCISE 1
+
+	var name string = "Emma"
+	country := "United States"
+	fmt.Printf("Your name: `%s`\nCountry: `%s`\n", name, country)
+
+	fmt.Println("He says: \"Hello\"")
+	fmt.Println(`C:\Users\a.txt`)
+
+	// EXERCISE 2
+
+	r := 'ă'
+	fmt.Printf("%T\n", r)
+
+	str1 := "ma"
+	str2 := "m"
+	str3 := str1 + str2 + string(r)
+	fmt.Println(str3)
+
+	// EXERCISE 3
+
+	s1 := "țară means country in Romanian"
+
+	fmt.Printf("Bytes in string: ")
+	for i := 0; i < len(s1); i++ {
+		fmt.Printf("%v ", s1[i])
+	}
+	fmt.Println("")
+
+	fmt.Printf("Byte characters in string: ")
+	for i := 0; i < len(s1); i++ {
+		fmt.Printf("%c ", s1[i])
+	}
+	fmt.Println("")
+
+	fmt.Printf("Runes with bytes in string:\n")
+	for i, v := range s1 {
+		fmt.Printf("%d -> %c\n", i, v)
+	}
+
+	// EXERCISE 4
+
+	s2 := "Go is cool!"
+	x := s2[0] // -> 71 (byte at G)
+	fmt.Println(x)
+
+	// s2[0] = 'x' // s2[0] is a byte, giving it a rune
+	// Strings are immutable
+	s2 = strings.Replace(s2, "G", "x", 1)
+
+	// printing the number of runes in the string
+	fmt.Println(len(s2))                    // -> 11 (returns number of bytes, which happens to be the length as well)
+	fmt.Println(utf8.RuneCountInString(s2)) // -> 11 (what we actually want)
+
+	fmt.Println(s2)
+
+	// EXERCISE 5
+
+	s := "你好 Go!"
+	ss := []byte(s)
+
+	fmt.Printf("%#v\n", ss)
+
+	for i, v := range ss {
+		fmt.Printf("%d -> %d\n", i, v)
+	}
+
+	// EXERCISE 6
+
+	rs := []rune(s)
+
+	fmt.Printf("%#v\n", rs)
+
+	for i, v := range rs {
+		fmt.Printf("%d -> %c\n", i, v)
+	}
+}
diff --git a/playing_with_go/master-go-programming/section_14/lesson_102-106/main.go b/playing_with_go/master-go-programming/section_14/lesson_102-106/main.go
new file mode 100644
index 0000000..0adff0e
--- /dev/null
+++ b/playing_with_go/master-go-programming/section_14/lesson_102-106/main.go
@@ -0,0 +1,139 @@
+/////////////////////////////////
+// Maps in Go
+// Go Playground: https://play.golang.org/p/BMtPVKuOwEQ
+/////////////////////////////////
+
+package main
+
+import "fmt"
+
+func main() {
+
+	// declaring a map with keys of type string and values of type string
+	var employees map[string]string
+	//the zero value of a map is nil
+
+	// the zero value of a map is nil
+	fmt.Printf("%#v\n", employees) // -> map[string]string(nil).
+
+	fmt.Printf("No. of elements: %d\n", len(employees)) // => No. of elements: 0
+
+	// getting the corresponding value of a key
+	// if the key doesn't exist or the map is not initialized it returns the zero value for the value type
+	fmt.Printf("The value for key %q is %q \n", "Dan", employees["Dan"]) // => The value for key "Dan" is ""
+
+	// key must be of comparable types
+	// var m1 map[[]int]string // error -> invalid map key type []int (slices are not comparable)
+
+	// inserting a key:value pair in a nil map
+	// employees["Dan"] = "Programmer" // error -> panic: assignment to entry in nil map
+
+	// declaring and initializing a map using a map literal
+	people := map[string]float64{} // empty map
+
+	// inserting key:value pairs in a map
+	people["John"] = 30.5
+	people["Mary"] = 22
+
+	fmt.Printf("%v\n", people) // => map[John:30.5 Mary:22]
+
+	// declaring and initializing a map using the make() function:
+	map1 := make(map[int]int)
+	fmt.Printf("map1: %#v\n", map1) // -> map1: map[int]int{}
+	map1[4] = 8
+
+	// declaring and initializing a map using a map literal
+	balances := map[string]float64{
+		"USD": 233.11,
+		"EUR": 555.11,
+		//50: "ABC"  //illegal, all keys have the same type which is string and all values have the same type which is float64
+		"CHF": 600, //this last comma (,) is mandatory when declaring the map on multiple lines
+	}
+	fmt.Println(balances) // => map[CHF:600 EUR:555.11 USD:233.11]
+
+	//If we declare and initialize a map on a single line, it's not mandatory to use a comma after the last element
+	m := map[int]int{1: 3, 4: 5, 6: 8}
+	_ = m
+
+	// initializing a map with duplicate keys
+	// n := map[int]int{1: 3, 4: 5, 6: 8, 1: 4} // error -> duplicate key 1 in map literal
+
+	// if the key exists it updates its value and if the key doesn't exist it adds the key: value pair
+	balances["USD"] = 500.5
+	balances["GBP"] = 800.8
+	fmt.Println(balances) // => map[CHF:600 EUR:555.11 GBP:800.8 USD:500.5]
+
+	// "comma ok" idiom is used to distinguish between a missing key:value pair and an existing key with value zero
+	v, ok := balances["RON"]
+
+	//v is the key's corresponding value
+	// ok is bool type value which is true if the key exists and false otherwise
+
+	if ok {
+		fmt.Println("The RON Balance is: ", v)
+	} else {
+		fmt.Println("The RON key doesn't exist in the map!")
+	}
+
+	// iterating over a map
+	for k, v := range balances {
+		fmt.Printf("Key: %#v, Value: %#v\n", k, v)
+	}
+
+	//starting with go 1.12 fmt.Printf() function prints out the map sorted by key.
+	fmt.Printf("balances: %v\n", balances) // => balances: map[CHF:600 EUR:555.11 GBP:800.8 USD:500.5]
+
+	// deleting a key:value pair from the map
+	delete(balances, "USD")
+
+	//** COMPARING MAPS **//
+
+	// Maps cannot be compared using == operator. A map can be compared only to nil.
+	a := map[string]string{"A": "X"}
+	b := map[string]string{"B": "X"}
+
+	// fmt.Println(a == b) // error -> invalid operation: a == b (map can only be compared to nil)
+
+	// to compare 2 maps that have the keys and values of type string
+	// we get a string representation of the maps and compare those strings.
+
+	// getting a string representation of maps called a and b
+	s1 := fmt.Sprintf("%s", a)
+	s2 := fmt.Sprintf("%s", b)
+
+	if s1 == s2 {
+		fmt.Println("Maps are equal")
+	} else {
+		fmt.Println("Maps are not equal")
+	}
+
+	//** CLONING A MAP **//
+
+	// When creating a map variable Go creates a pointer to a map header value in memory.
+	// The key: value pairs of the map are not stored directly into the map.
+	// They are stored in memory at the address referenced by the map header.
+
+	friends := map[string]int{"Dan": 40, "Maria": 35}
+
+	// neighbors is not a copy of friends.
+	// both maps reference the same data structure in memory
+	neighbors := friends
+
+	// modifying friends AND neighbors
+	friends["Dan"] = 30
+
+	fmt.Println(neighbors) // -> map[Dan:30 Maria:35]
+
+	// How to clone a map?
+	// 1. initialize a new map
+	colleagues := make(map[string]int)
+
+	// colleagues = friends // -> ERROR, illegal with maps!
+
+	// 2. use a for loop to copy each element into the new map
+	for k, v := range friends {
+		colleagues[k] = v
+	}
+
+	// colleagues and friends are different maps in memory!
+}
diff --git a/playing_with_go/master-go-programming/section_15/lesson_107/main.go b/playing_with_go/master-go-programming/section_15/lesson_107/main.go
new file mode 100644
index 0000000..a967f77
--- /dev/null
+++ b/playing_with_go/master-go-programming/section_15/lesson_107/main.go
@@ -0,0 +1,49 @@
+package main
+
+import "fmt"
+
+func main() {
+	// EXERCISE 1
+
+	var m1 map[string]string
+	fmt.Printf("Type: %T, Value: %#v\n", m1, m1)
+
+	m2 := map[int]string{1: "Taylor Swift", 2: "The Beatles"}
+	m2[10] = "Abba"
+
+	fmt.Printf("Value of %d: %q\n", 1, m2[1])
+	fmt.Printf("Value of %d: %q\n", 3, m2[3])
+
+	// EXERCISE 2
+
+	// var m3 map[int]bool
+	// m3[5] = true // may fail... m3 is nil.. instead:
+	m3 := map[int]bool{}
+	m3[5] = true
+
+	m4 := map[int]int{3: 10, 4: 40}
+	m5 := map[int]int{3: 10, 4: 40}
+
+	// fmt.Println(m4 == m5) // cannot compare maps together like this
+
+	equal := true
+	for k, v := range m4 {
+		if m5[k] == v {
+			continue
+		} else {
+			equal = false
+			break
+		}
+	}
+	fmt.Printf("The two arrays are equal: %v\n", equal)
+
+	// EXERCISE 3
+
+	// m := map[int]bool{"1": true, 2: false, 3: false} // "1" is a string
+	m := map[int]bool{1: true, 2: false, 3: false}
+	delete(m, 2)
+
+	for k, v := range m {
+		fmt.Println(k, "->", v)
+	}
+}
diff --git a/playing_with_go/master-go-programming/section_16/lesson_108-109/main.go b/playing_with_go/master-go-programming/section_16/lesson_108-109/main.go
new file mode 100644
index 0000000..8fdec46
--- /dev/null
+++ b/playing_with_go/master-go-programming/section_16/lesson_108-109/main.go
@@ -0,0 +1,106 @@
+/////////////////////////////////
+// Creating, Opening, Closing, Renaming, Moving, and Removing files in Go
+// Go Playground: https://play.golang.org/p/Sz_LfNS9GKU
+/////////////////////////////////
+
+package main
+
+import (
+	"fmt"
+	"log"
+	"os"
+)
+
+func main() {
+
+	//** Use valid paths according to your OS. **//
+
+	// CREATING A FILE
+
+	// os.Create() function creates a file if it doesn't already exist. If it exists, the file is truncated.
+	// it returns a file descriptor which is a pointer to os.File and an error value.
+	newFile, err := os.Create("a.txt")
+
+	// error handling
+	if err != nil {
+		// log the error and exit the program
+		log.Fatal(err) // the idiomatic way to handle errors
+
+	}
+
+	// TRUNCATING A FILE
+	err = os.Truncate("a.txt", 0) //0 means completely empty the file.
+
+	// error handling
+	if err != nil {
+		log.Fatal(err)
+	}
+
+	// CLOSING THE FILE
+	newFile.Close()
+
+	// OPEN AND CLOSE AN EXISTING FILE
+	file, err := os.Open("a.txt") // open in read-only mode
+
+	// error handling
+	if err != nil {
+		log.Fatal(err)
+	}
+	file.Close()
+
+	//OPENING a FILE WITH MORE OPTIONS
+	file, err = os.OpenFile("a.txt", os.O_APPEND, 0644)
+	// We can Use opening attributes individually or combined
+	// using an OR between them
+	// e.g. os.O_CREATE|os.O_APPEND
+	// or os.O_CREATE|os.O_TRUNC|os.O_WRONLY
+	// os.O_RDONLY // Read only
+	// os.O_WRONLY // Write only
+	// os.O_RDWR // Read and write
+	// os.O_APPEND // Append to end of file
+	// os.O_CREATE // Create is none exist
+	// os.O_TRUNC // Truncate file when opening
+
+	// error handling
+	if err != nil {
+		log.Fatal(err)
+	}
+	file.Close()
+
+	// GETTING FILE INFO
+	var fileInfo os.FileInfo
+	fileInfo, _ = os.Stat("a.txt")
+
+	p := fmt.Println
+	p("File Name:", fileInfo.Name())        // => File Name: a.txt
+	p("Size in bytes:", fileInfo.Size())    // => Size in bytes: 0
+	p("Last modified:", fileInfo.ModTime()) // => Last modified: 2019-10-21 16:16:00.325037748 +0300 EEST
+	p("Is Directory? ", fileInfo.IsDir())   // => Is Directory?  false
+	p("Pemissions:", fileInfo.Mode())       // => Pemissions: -rw-r-----
+
+	// CHECKING IF FILE EXISTS
+	_, err = os.Stat("b.txt")
+	// error handling
+	if err != nil {
+		if os.IsNotExist(err) {
+			log.Fatal("The file does not exist")
+		}
+	}
+
+	// RENAMING AND MOVING A FILE
+	oldPath := "a.txt"
+	newPath := "aaa.txt"
+	err = os.Rename(oldPath, newPath)
+	// error handling
+	if err != nil {
+		log.Fatal(err)
+	}
+
+	// REMOVING A FILE
+	err = os.Remove("aa.txt")
+	// error handling
+	if err != nil {
+		log.Fatal(err)
+	}
+
+}
diff --git a/playing_with_go/master-go-programming/section_16/lesson_110-111/main.go b/playing_with_go/master-go-programming/section_16/lesson_110-111/main.go
new file mode 100644
index 0000000..316ee49
--- /dev/null
+++ b/playing_with_go/master-go-programming/section_16/lesson_110-111/main.go
@@ -0,0 +1,53 @@
+/////////////////////////////////
+// Writing Bytes to Files
+// Go Playground: https://play.golang.org/p/Zc3KDG7kYvt
+/////////////////////////////////
+
+package main
+
+import (
+	"io/ioutil"
+	"log"
+	"os"
+)
+
+func main() {
+
+	// opening the file in write-only mode if the file exists and then it truncates the file.
+	// if the file doesn't exist it creates the file with 0644 permissions
+	file, err := os.OpenFile(
+		"b.txt",
+		os.O_WRONLY|os.O_TRUNC|os.O_CREATE,
+		0644,
+	)
+	// error handling
+	if err != nil {
+		log.Fatal(err)
+	}
+	// defer closing the file
+	defer file.Close()
+
+	// WRITING BYTES TO FILE
+
+	byteSlice := []byte("I learn Golang! 传")   // converting a string to a bytes slice
+	bytesWritten, err := file.Write(byteSlice) // writing bytes to file.
+	// It returns the no. of bytes written and an error value
+	// error handling
+	if err != nil {
+		log.Fatal(err)
+	}
+	log.Printf("Bytes written: %d\n", bytesWritten) // => 2019/10/21 16:26:16 Bytes written: 19
+
+	// WRITING BYTES TO FILE USING ioutil.WriteFile()
+
+	// ioutil.WriteFile() handles creating, opening, writing a slice of bytes and closing the file.
+	// if the file doesn't exist WriteFile() creates it
+	// and if it already exists the function will truncate it before writing to file.
+
+	bs := []byte("Go Programming is cool!")
+	err = ioutil.WriteFile("c.txt", bs, 0644)
+	// error handling
+	if err != nil {
+		log.Fatal(err)
+	}
+}
diff --git a/playing_with_go/master-go-programming/section_16/lesson_112-113/main.go b/playing_with_go/master-go-programming/section_16/lesson_112-113/main.go
new file mode 100644
index 0000000..06fa095
--- /dev/null
+++ b/playing_with_go/master-go-programming/section_16/lesson_112-113/main.go
@@ -0,0 +1,67 @@
+/////////////////////////////////
+// Writing to Files using a Buffer in Memory
+// Go Playground: https://play.golang.org/p/7U3g_B33aui
+/////////////////////////////////
+
+package main
+
+import (
+	"bufio"
+	"log"
+	"os"
+)
+
+func main() {
+
+	// Opening the file for writing
+	file, err := os.OpenFile("my_file.txt", os.O_APPEND|os.O_CREATE, 0644)
+	// error handling
+	if err != nil {
+		log.Fatal(err)
+	}
+	// defer closing the file
+	defer file.Close()
+
+	// Creating a buffered writer from the file variable using bufio.NewWriter()
+	bufferedWriter := bufio.NewWriter(file)
+
+	// declaring a byte slice
+	bs := []byte{97, 98, 99}
+
+	// writing the byte slice to the buffer in memory
+	bytesWritten, err := bufferedWriter.Write(bs)
+
+	// error handling
+	if err != nil {
+		log.Fatal(err)
+	}
+	log.Printf("Bytes written to buffer (not file): %d\n", bytesWritten)
+	// => 2019/10/21 16:30:59 Bytes written to buffer (not file): 3
+
+	// checking the available buffer
+	bytesAvailable := bufferedWriter.Available()
+	log.Printf("Bytes available in buffer: %d\n", bytesAvailable)
+	// => 2019/10/21 16:30:59 Bytes available in buffer: 4093
+
+	// writing a string (not a byte slice) to the buffer in memory
+	_, err = bufferedWriter.WriteString("\nJust a random string")
+
+	// error handling
+	if err != nil {
+		log.Fatal(err)
+	}
+
+	// checking how much data is stored in buffer, just  waiting to be written to disk
+	unflushedBufferSize := bufferedWriter.Buffered()
+	log.Printf("Bytes buffered: %d\n", unflushedBufferSize)
+	// -> 24 (3 bytes in the byte slice + 21 runes in the string, each rune is 1 byte)
+
+	// The bytes have been written to buffer, not yet to file.
+	// Writing from buffer to file.
+	bufferedWriter.Flush()
+
+	// Flush empties out the buffer when it writes to the file, but
+	// to reset the buffer:
+	bufferedWriter.Reset(bufferedWriter)
+	log.Printf("Bytes buffered: %d\n", bufferedWriter.Buffered())
+}
diff --git a/playing_with_go/master-go-programming/section_16/lesson_114-115/main.go b/playing_with_go/master-go-programming/section_16/lesson_114-115/main.go
new file mode 100644
index 0000000..abc3c8d
--- /dev/null
+++ b/playing_with_go/master-go-programming/section_16/lesson_114-115/main.go
@@ -0,0 +1,71 @@
+/////////////////////////////////
+// Reading Files in Go
+// Go Playground: https://play.golang.org/p/LJnTSVfaJW_R
+/////////////////////////////////
+
+package main
+
+import (
+	"fmt"
+	"io"
+	"io/ioutil"
+	"log"
+	"os"
+	"strings"
+)
+
+func main() {
+
+	//** READING INTO A BYTE SLICE USING io.ReadFull() **//
+
+	// Opening the file in read-only mode. The file must exist (in the current working directory)
+	// Use a valid path!
+	file, err := os.Open("test.md")
+	if err != nil {
+		log.Fatal(err)
+	}
+	defer file.Close()
+
+	// declaring a byte slice and initializing it with a length of 2
+	byteSlice := make([]byte, 2)
+
+	// io.ReadFull() returns an error if the file is smaller than the byte slice.
+	// it reads the file into the byte slice up to its length
+	numberBytesRead, err := io.ReadFull(file, byteSlice)
+	if err != nil {
+		log.Fatal(err)
+	}
+	log.Printf("Number of bytes read: %d\n", numberBytesRead)
+	log.Printf("Data read: %s\n", byteSlice)
+
+	fmt.Println(strings.Repeat("#", 20))
+
+	//** READING WHOLE FILE INTO A BYTESLICE USING ioutil.ReadAll() **//
+
+	// Opening another file (from the current working directory)
+	file, err = os.Open("test.md")
+	if err != nil {
+		log.Fatal(err)
+	}
+
+	// ioutil.ReadAll() reads every byte from the file and return a slice of unknown size
+	data, err := ioutil.ReadAll(file)
+	if err != nil {
+		log.Fatal(err)
+	}
+
+	fmt.Printf("Data as string: %s\n", data)
+	fmt.Printf("Data type: %T\n", data)
+	fmt.Println("Number of bytes read:", len(data))
+
+	//** READING WHOLE FILE INTO MEMORY USING ioutil.ReadFile() **//
+
+	// ioutil.ReadFile() reads a file into byte slice
+	// this function handles opening and closing the file.
+	data, err = ioutil.ReadFile("test.md")
+	if err != nil {
+		log.Fatal(err)
+	}
+	fmt.Printf("Data read: %s\n", data)
+	fmt.Println("Number of bytes read:", len(data))
+}
diff --git a/playing_with_go/master-go-programming/section_16/lesson_116-117/main.go b/playing_with_go/master-go-programming/section_16/lesson_116-117/main.go
new file mode 100644
index 0000000..8cac7b4
--- /dev/null
+++ b/playing_with_go/master-go-programming/section_16/lesson_116-117/main.go
@@ -0,0 +1,59 @@
+/////////////////////////////////
+// Reading Files Line by Line (or using a delimiter) using bufio.Scanner
+// Go Playground: https://play.golang.org/p/v0o0H4huUDR
+/////////////////////////////////
+
+package main
+
+import (
+	"bufio"
+	"fmt"
+	"log"
+	"os"
+)
+
+func main() {
+
+	// opening the file in read-only mode. The file must exist (in the current working directory)
+	// use a valid path!
+	file, err := os.Open("test.md")
+	// error handling
+	if err != nil {
+		log.Fatal(err)
+	}
+	// defer closing the file
+	defer file.Close()
+
+	// the file value returned by os.Open() is wrapped in a bufio.Scanner just like a buffered reader.
+	scanner := bufio.NewScanner(file)
+
+	// the default scanner is bufio.ScanLines and that means it will scan a file line by line.
+	// there are also bufio.ScanWords and bufio.ScanRunes.
+	// scanner.Split(bufio.ScanLines)
+
+	// scanning for next token in this case \n which is the line delimiter.
+	success := scanner.Scan() //read a line
+	if !success {
+		// false on error or EOF. Check for errors
+		err = scanner.Err()
+		if err == nil {
+			log.Println("Scan was completed and it reached End Of File.")
+		} else {
+			log.Fatal(err)
+		}
+	}
+
+	// Getting the data from the scanner with Bytes() or Text()
+	fmt.Printf("First Line found:\n%s", scanner.Text())
+	//If we want the next token, so the next line or \n, we call scanner.Scan() again
+
+	// Reading the whole remaining part of the file:
+	for scanner.Scan() {
+		fmt.Println(scanner.Text())
+	}
+
+	// Checking for any possible errors:
+	if err := scanner.Err(); err != nil {
+		log.Fatal(err)
+	}
+}
diff --git a/playing_with_go/master-go-programming/section_16/lesson_118-119/main.go b/playing_with_go/master-go-programming/section_16/lesson_118-119/main.go
new file mode 100644
index 0000000..1f904fc
--- /dev/null
+++ b/playing_with_go/master-go-programming/section_16/lesson_118-119/main.go
@@ -0,0 +1,44 @@
+/////////////////////////////////
+// Reading From Standard Input (console)
+// Go Playground: https://play.golang.org/p/n8JuneN40_p
+/////////////////////////////////
+
+package main
+
+import (
+	"bufio"
+	"fmt"
+	"log"
+	"os"
+)
+
+func main() {
+
+	// creating a scanner
+	scanner := bufio.NewScanner(os.Stdin) //os.Stdin reads the output from the command line
+	fmt.Printf("%T\n", scanner)           //pointer to bufio.scanner
+
+	scanner.Scan() //it waits for the input and buffers the input untill a new line
+
+	// gettting the scanned data
+	text := scanner.Text()   // string type
+	bytes := scanner.Bytes() // uint8[] slice type
+
+	fmt.Println("Input text:", text)
+	fmt.Println("Input bytes:", bytes)
+
+	// reading the input continously until a specific string is scanned
+	for scanner.Scan() {
+		text = scanner.Text()
+		fmt.Println("You entered:", text)
+		if text == "exit" {
+			fmt.Println("Exiting the scanning ...")
+			break
+		}
+	}
+
+	// error handling
+	if err := scanner.Err(); err != nil {
+		log.Println(err)
+	}
+}
diff --git a/playing_with_go/master-go-programming/section_16/test.md b/playing_with_go/master-go-programming/section_16/test.md
new file mode 100644
index 0000000..a95ff02
--- /dev/null
+++ b/playing_with_go/master-go-programming/section_16/test.md
@@ -0,0 +1,18 @@
+This is my test example file.
+
+It has some newlines...
+  And some spaces.
+
+And some wonky characters:
+
+```go
+package main
+
+import (
+    "fmt"
+)
+
+func main() {
+  fmt.Println("Hello")
+}
+```
diff --git a/playing_with_go/master-go-programming/section_17/lesson_120/main.go b/playing_with_go/master-go-programming/section_17/lesson_120/main.go
new file mode 100644
index 0000000..1b73102
--- /dev/null
+++ b/playing_with_go/master-go-programming/section_17/lesson_120/main.go
@@ -0,0 +1,85 @@
+package main
+
+import (
+	"bufio"
+	"fmt"
+	"log"
+	"os"
+	"strings"
+)
+
+func main() {
+	// EXERCISE 1
+
+	file, err := os.Create("info.txt")
+	if err != nil {
+		log.Fatal(err)
+	}
+
+	file.Close()
+
+	// EXERCISE 2
+
+	_, err = os.Stat("info.txt")
+	if err != nil {
+		if os.IsNotExist(err) {
+			log.Fatal(err)
+		}
+	}
+
+	os.Rename("info.txt", "newInfo.txt")
+
+	// EXERCISE 3
+
+	err = os.Remove("newInfo.txt")
+	if err != nil {
+		log.Fatal(err)
+	}
+
+	// EXERCISE 4
+
+	// os.ReadFile will open and close the file for you
+	// It's a more updated alternative to ioutil.ReadAll()
+	readFile, err := os.ReadFile("test.md")
+	if err != nil {
+		log.Fatal(err)
+	}
+
+	fmt.Printf("readFile type: %T\n", readFile)
+	fmt.Println("File as bytes:", readFile)
+	fmt.Println("File as string:", string(readFile))
+
+	// EXERCISE 5
+
+	fmt.Println(strings.Repeat("#", 100))
+	fmt.Println("")
+
+	file, err = os.Open("test.md")
+	if err != nil {
+		log.Fatal(err)
+	}
+	defer file.Close()
+
+	scanner := bufio.NewScanner(file)
+	for scanner.Scan() {
+		fmt.Println(scanner.Text())
+	}
+	if scanner.Err() != nil {
+		log.Fatal(scanner.Err())
+	}
+
+	// EXERCISE 6
+
+	file, err = os.Create("new.txt")
+	if err != nil {
+		log.Fatal(err)
+	}
+	defer file.Close()
+
+	bufferedWriter := bufio.NewWriter(file)
+	_, err = bufferedWriter.WriteString("The Go gopher is an iconic mascot!")
+	if err != nil {
+		log.Fatal(err)
+	}
+	bufferedWriter.Flush()
+}
diff --git a/playing_with_go/master-go-programming/section_17/new.txt b/playing_with_go/master-go-programming/section_17/new.txt
new file mode 100644
index 0000000..50d9824
--- /dev/null
+++ b/playing_with_go/master-go-programming/section_17/new.txt
@@ -0,0 +1 @@
+The Go gopher is an iconic mascot!
\ No newline at end of file
diff --git a/playing_with_go/master-go-programming/section_17/test.md b/playing_with_go/master-go-programming/section_17/test.md
new file mode 100644
index 0000000..53f7bf1
--- /dev/null
+++ b/playing_with_go/master-go-programming/section_17/test.md
@@ -0,0 +1,5 @@
+This is my single file with a long string
+
+Now there's another long string.
+
+Let's see what the outcome of this is.
